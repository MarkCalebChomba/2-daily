import ccxt
import pandas as pd
import numpy as np
import math
import ta
import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List
import warnings
import io
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

warnings.filterwarnings('ignore')
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('BybitBot')

class EmailNotifier:
    def __init__(self, sender="markcalebchomba@gmail.com", receiver="achiverscollege6@gmail.com", password="leug erco myri ncxv"):
        self.sender = sender
        self.receiver = receiver
        self.password = password
        self.last_email = datetime.now() - timedelta(hours=1)
        self.last_report = datetime.now()
    
    def send_email(self, subject, body, csv_data=None, csv_name="report.csv"):
        try:
            if (datetime.now() - self.last_email).total_seconds() < 600:
                return False
            
            msg = MIMEMultipart()
            msg['From'] = self.sender
            msg['To'] = self.receiver
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))
            
            if csv_data:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(csv_data.encode('utf-8'))
                encoders.encode_base64(part)
                part.add_header('Content-Disposition', f'attachment; filename={csv_name}')
                msg.attach(part)
            
            with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
                server.login(self.sender, self.password)
                server.send_message(msg)
            
            self.last_email = datetime.now()
            logger.info(f"Email sent: {subject}")
            return True
        except Exception as e:
            logger.error(f"Email failed: {e}")
            return False
    
    def send_periodic_report(self, stats: dict, trades: list, alien_trades: list):
        if (datetime.now() - self.last_report).total_seconds() < 43200:
            return False
        
        alien_info = f"\n⚠ ALIEN TRADES: {len(alien_trades)}" if alien_trades else ""
        
        body = f"""
12-Hour Trading Report
=====================
Balance: ${stats['balance']:.2f}
Session Start: ${stats['start_balance']:.2f}
P&L: ${stats['pnl']:.2f} ({stats['pnl_pct']:.2f}%)

Positions: {stats['positions']} (L:{stats['longs']}, S:{stats['shorts']}){alien_info}
Trades: {stats['total']} (W:{stats['won']}, L:{stats['lost']}, WR:{stats['win_rate']:.1f}%)
Peak P&L: ${stats['peak_pnl']:.2f}

Bot Status: Running
"""
        
        csv_data = self._create_csv(trades, alien_trades, stats)
        csv_name = f"bybit_report_{datetime.now().strftime('%Y%m%d_%H%M')}.csv"
        
        result = self.send_email(f"Bybit 12H Report - {datetime.now().strftime('%Y-%m-%d %H:%M')}", body, csv_data, csv_name)
        if result:
            self.last_report = datetime.now()
        return result
    
    def send_session_end(self, stats: dict, trades: list, alien_trades: list):
        body = f"""
Session Completed
================
Duration: {stats['duration']:.1f} minutes
Final Balance: ${stats['balance']:.2f}
P&L: ${stats['pnl']:.2f} ({stats['pnl_pct']:.2f}%)

Trades: {stats['total']} (W:{stats['won']}, L:{stats['lost']}, WR:{stats['win_rate']:.1f}%)
Max Drawdown: {stats['max_dd']:.2f}%
Alien Trades: {len(alien_trades)}
"""
        csv_data = self._create_csv(trades, alien_trades, stats)
        csv_name = f"bybit_session_{datetime.now().strftime('%Y%m%d_%H%M')}.csv"
        self.send_email(f"Bybit Session End - {datetime.now().strftime('%Y-%m-%d %H:%M')}", body, csv_data, csv_name)
    
    def _create_csv(self, trades: list, alien_trades: list, stats: dict):
        output = io.StringIO()
        
        # Session summary
        output.write("SESSION SUMMARY\n")
        output.write(f"Start Time,{stats.get('start_time', 'N/A')}\n")
        output.write(f"End Time,{datetime.now().isoformat()}\n")
        output.write(f"Duration (min),{stats.get('duration', 0):.1f}\n")
        output.write(f"Start Balance,{stats.get('start_balance', 0):.2f}\n")
        output.write(f"End Balance,{stats['balance']:.2f}\n")
        output.write(f"P&L,{stats['pnl']:.2f}\n")
        output.write(f"P&L %,{stats['pnl_pct']:.2f}\n")
        output.write(f"Trades Total,{stats['total']}\n")
        output.write(f"Won,{stats['won']}\n")
        output.write(f"Lost,{stats['lost']}\n")
        output.write(f"Win Rate %,{stats['win_rate']:.2f}\n")
        output.write(f"Max Drawdown %,{stats.get('max_dd', 0):.2f}\n\n")
        
        # Bot trades
        output.write("BOT TRADES\n")
        output.write("Timestamp,Symbol,Direction,Entry,Exit,P&L,P&L%,Status,Reason\n")
        for t in trades:
            output.write(f"{t['timestamp']},{t['symbol']},{t['direction']},{t['entry_price']:.6f},{t['exit_price']:.6f},{t['pnl']:.2f},{t['pnl_pct']:.2f},{t['status']},{t.get('reason','')}\n")
        
        # Alien trades
        if alien_trades:
            output.write("\nALIEN TRADES (NOT MANAGED BY BOT)\n")
            output.write("Detected At,Symbol,Direction,Entry Price,Current Price,Unrealized P&L\n")
            for a in alien_trades:
                output.write(f"{a['detected_at']},{a['symbol']},{a['direction']},{a['entry_price']:.6f},{a['current_price']:.6f},{a['unrealized_pnl']:.2f}\n")
        
        return output.getvalue()
    
    def send_alert(self, msg):
        self.send_email(f"⚠ Bybit Alert - {datetime.now().strftime('%H:%M')}", msg)

class SessionTracker:
    def __init__(self):
        self.start_time = datetime.now()
        self.start_balance = 0
        self.trades = []
        self.alien_trades = []
        self.peak_balance = 0
        self.max_dd = 0
        self.won = 0
        self.lost = 0
    
    def start(self, balance):
        self.start_time = datetime.now()
        self.start_balance = balance
        self.peak_balance = balance
        self.trades = []
        self.alien_trades = []
        self.max_dd = 0
        self.won = self.lost = 0
    
    def update_balance(self, balance):
        if balance > self.peak_balance:
            self.peak_balance = balance
        else:
            dd = ((self.peak_balance - balance) / self.peak_balance) * 100
            self.max_dd = max(self.max_dd, dd)
    
    def add_trade(self, symbol, direction, entry, exit, pnl, pnl_pct, status, reason=""):
        self.trades.append({
            'timestamp': datetime.now().isoformat(),
            'symbol': symbol,
            'direction': direction,
            'entry_price': entry,
            'exit_price': exit,
            'pnl': pnl,
            'pnl_pct': pnl_pct,
            'status': status,
            'reason': reason
        })
        if status == 'won':
            self.won += 1
        elif status == 'lost':
            self.lost += 1
    
    def add_alien(self, symbol, direction, entry, current, pnl):
        self.alien_trades.append({
            'detected_at': datetime.now().isoformat(),
            'symbol': symbol,
            'direction': direction,
            'entry_price': entry,
            'current_price': current,
            'unrealized_pnl': pnl
        })

class BybitBot:
    def __init__(self, api_key: str, api_secret: str):
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': api_secret,
            'enableRateLimit': True,
            'options': {'defaultType': 'swap', 'adjustForTimeDifference': True, 'recvWindow': 10000},
            'timeout': 30000,
            'rateLimit': 100
        })
        self.exchange.load_time_difference()
        self.exchange.load_markets()
        
        self.positions = {}
        self.known_symbols = set()
        self.alien_symbols = set()
        self.failed_symbols = set()
        self.leverage = 20
        self.max_longs = 10
        self.max_shorts = 10
        self.tracker = SessionTracker()
        self.notifier = EmailNotifier()
        self.active = False
        self.monitoring = False
        self.portfolio_peak = 0
        self.last_alien_check = datetime.now()
        self.last_tpsl_check = datetime.now()
        self.order_reset = datetime.now()
    
    def get_balance(self):
        try:
            bal = self.exchange.fetch_balance()
            return float(bal.get('USDT', {}).get('free', 0))
        except Exception as e:
            logger.error(f"Balance error: {e}")
            return 0
    
    def get_symbols(self):
        try:
            markets = self.exchange.load_markets()
            symbols = []
            for sym, market in markets.items():
                if market.get('swap') and market.get('quote') == 'USDT' and market.get('settle') == 'USDT':
                    try:
                        ticker = self.exchange.fetch_ticker(sym)
                        if ticker.get('baseVolume'):
                            market['volume'] = ticker['baseVolume']
                            symbols.append(market)
                    except:
                        continue
            symbols.sort(key=lambda x: x.get('volume', 0), reverse=True)
            return symbols[:100]
        except:
            return []
    
    def fetch_ohlcv(self, symbol: str, tf: str, limit: int = 200):
        try:
            data = self.exchange.fetch_ohlcv(symbol, tf, limit=limit)
            if not data:
                return pd.DataFrame()
            df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)
            return df
        except:
            return pd.DataFrame()
    
    def analyze(self, df: pd.DataFrame):
        if df.empty or len(df) < 50:
            return {'score': 0, 'direction': 'neutral', 'vwap_data': None}
        
        try:
            # VWAP with bands
            tp = (df['high'] + df['low'] + df['close']) / 3
            vwap = (tp * df['volume']).rolling(20).sum() / df['volume'].rolling(20).sum()
            std = ((tp - vwap) ** 2).rolling(20).mean().apply(np.sqrt)
            
            if vwap.isna().all():
                return {'score': 0, 'direction': 'neutral', 'vwap_data': None}
            
            price = df['close'].iloc[-1]
            vwap_data = {
                'vwap': vwap.iloc[-1],
                'upper': vwap.iloc[-1] + (2 * std.iloc[-1]),
                'lower': vwap.iloc[-1] - (2 * std.iloc[-1])
            }
            
            long_sig = short_sig = 0
            
            # 1. RSI (Inverted: overbought = long, oversold = short)
            rsi = ta.momentum.RSIIndicator(df['close'], 14).rsi().iloc[-1]
            if rsi > 70:
                long_sig += 1
            elif rsi < 30:
                short_sig += 1
            
            # 2. MACD (Inverted: negative histogram = long)
            macd = ta.trend.MACD(df['close'])
            if macd.macd_diff().iloc[-1] < 0:
                long_sig += 1
            elif macd.macd_diff().iloc[-1] > 0:
                short_sig += 1
            
            # 3. Bollinger Bands (Inverted: above upper = long)
            bb = ta.volatility.BollingerBands(df['close'], 20, 2)
            if price > bb.bollinger_hband().iloc[-1]:
                long_sig += 1
            elif price < bb.bollinger_lband().iloc[-1]:
                short_sig += 1
            
            # 4. Stochastic (Inverted: overbought = long)
            stoch = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close'], 14, 3)
            if stoch.stoch().iloc[-1] > 80:
                long_sig += 1
            elif stoch.stoch().iloc[-1] < 20:
                short_sig += 1
            
            # 5. VWAP (Inverted: above = long)
            if price > vwap_data['vwap']:
                long_sig += 1
            else:
                short_sig += 1
            
            # 6. EMA 20 (Inverted: above = long)
            ema = ta.trend.EMAIndicator(df['close'], 20).ema_indicator().iloc[-1]
            if price > ema:
                long_sig += 1
            elif price < ema:
                short_sig += 1
            
            # 7. ADX (Trend strength + direction)
            adx = ta.trend.ADXIndicator(df['high'], df['low'], df['close'], 14)
            if not adx.adx().isna().all() and adx.adx().iloc[-1] > 25:
                if price > df['close'].iloc[-10]:
                    long_sig += 1
                elif price < df['close'].iloc[-10]:
                    short_sig += 1
            
            # 8. Williams %R (Inverted: overbought = long)
            williams = ta.momentum.WilliamsRIndicator(df['high'], df['low'], df['close'], 14)
            if not williams.williams_r().isna().all():
                wr = williams.williams_r().iloc[-1]
                if wr > -20:
                    long_sig += 1
                elif wr < -80:
                    short_sig += 1
            
            # 9. CCI (Inverted: overbought = long)
            cci = ta.trend.CCIIndicator(df['high'], df['low'], df['close'], 20)
            if not cci.cci().isna().all():
                cci_val = cci.cci().iloc[-1]
                if cci_val > 100:
                    long_sig += 1
                elif cci_val < -100:
                    short_sig += 1
            
            # 10. MFI (Inverted: overbought = long)
            mfi = ta.volume.MFIIndicator(df['high'], df['low'], df['close'], df['volume'], 14)
            if not mfi.money_flow_index().isna().all():
                mfi_val = mfi.money_flow_index().iloc[-1]
                if mfi_val > 80:
                    long_sig += 1
                elif mfi_val < 20:
                    short_sig += 1
            
            score = max(long_sig, short_sig) * 10
            direction = 'long' if long_sig > short_sig else ('short' if short_sig > long_sig else 'neutral')
            
            return {'score': score, 'direction': direction, 'vwap_data': vwap_data}
        except Exception as e:
            logger.error(f"Analysis error: {e}")
            return {'score': 0, 'direction': 'neutral', 'vwap_data': None}
    
    def find_opportunities(self, symbols):
        longs = []
        shorts = []
        
        for sym_info in symbols[:150]:
            symbol = sym_info['symbol']
            
            if symbol in self.failed_symbols or symbol in self.alien_symbols or symbol in self.positions:
                continue
            
            df_4h = self.fetch_ohlcv(symbol, '4h', 100)
            analysis_4h = self.analyze(df_4h)
            
            if analysis_4h['score'] >= 50 and analysis_4h['vwap_data']:
                df_15m = self.fetch_ohlcv(symbol, '15m', 100)
                analysis_15m = self.analyze(df_15m)
                
                if analysis_15m['score'] >= 50 and analysis_15m['vwap_data'] and analysis_4h['direction'] == analysis_15m['direction']:
                    ticker = self.exchange.fetch_ticker(symbol)
                    
                    trade = {
                        'symbol': symbol,
                        'direction': analysis_4h['direction'],
                        'score': (analysis_4h['score'] + analysis_15m['score']) / 2,
                        'price': ticker['last'],
                        'vwap_data': analysis_15m['vwap_data']
                    }
                    
                    if analysis_4h['direction'] == 'long':
                        longs.append(trade)
                    else:
                        shorts.append(trade)
        
        longs.sort(key=lambda x: x['score'], reverse=True)
        shorts.sort(key=lambda x: x['score'], reverse=True)
        
        return longs, shorts
    
    def get_exposure(self):
        try:
            positions = self.exchange.fetch_positions()
            orders = self.exchange.fetch_open_orders()
            
            long_syms = set()
            short_syms = set()
            
            for p in positions:
                if float(p.get('contracts', 0)) > 0:
                    sym = p['symbol']
                    if sym not in self.alien_symbols:
                        if p['side'] == 'long':
                            long_syms.add(sym)
                        else:
                            short_syms.add(sym)
            
            for o in orders:
                if o.get('status') == 'open':
                    sym = o['symbol']
                    if sym not in self.alien_symbols:
                        if o['side'] == 'buy' and sym not in long_syms:
                            long_syms.add(sym)
                        elif o['side'] == 'sell' and sym not in short_syms:
                            short_syms.add(sym)
            
            return len(long_syms), len(short_syms)
        except:
            return 0, 0
    
    async def detect_aliens(self):
        if (datetime.now() - self.last_alien_check).total_seconds() < 300:
            return
        
        self.last_alien_check = datetime.now()
        
        try:
            positions = self.exchange.fetch_positions()
            new_aliens = []
            
            for pos in positions:
                if float(pos.get('contracts', 0)) > 0:
                    sym = pos['symbol']
                    if sym not in self.known_symbols and sym not in self.alien_symbols:
                        self.alien_symbols.add(sym)
                        new_aliens.append(sym)
                        
                        self.tracker.add_alien(
                            sym,
                            'long' if pos['side'] == 'long' else 'short',
                            float(pos.get('entryPrice', 0)),
                            float(pos.get('markPrice', 0)),
                            float(pos.get('unrealisedPnl', 0))
                        )
                        logger.warning(f"👽 ALIEN: {sym}")
            
            if new_aliens:
                self.notifier.send_alert(f"👽 Alien trades detected:\n{chr(10).join(new_aliens)}")
        except Exception as e:
            logger.error(f"Alien detection error: {e}")
    
    async def check_add_tpsl(self):
        """Check positions without TP/SL and add them - Enhanced version"""
        if (datetime.now() - self.last_tpsl_check).total_seconds() < 30:  # Check more frequently (30s)
            return
        
        self.last_tpsl_check = datetime.now()
        
        try:
            positions = self.exchange.fetch_positions()
            fixed_count = 0
            
            for pos in positions:
                if float(pos.get('contracts', 0)) <= 0:
                    continue
                
                sym = pos['symbol']
                
                # Skip alien trades
                if sym in self.alien_symbols:
                    continue
                
                # Check if TP/SL missing
                has_tp = pos.get('takeProfit') and float(pos.get('takeProfit', 0)) > 0
                has_sl = pos.get('stopLoss') and float(pos.get('stopLoss', 0)) > 0
                
                if not has_tp or not has_sl:
                    logger.warning(f"⚠ {sym} missing TP/SL - Adding now...")
                    
                    entry = float(pos.get('entryPrice', 0))
                    direction = 'long' if pos['side'] == 'long' else 'short'
                    position_idx = 1 if direction == 'long' else 2
                    
                    # Get current VWAP data
                    df = self.fetch_ohlcv(sym, '15m', 100)
                    analysis = self.analyze(df)
                    
                    if analysis['vwap_data']:
                        vwap_data = analysis['vwap_data']
                        
                        if direction == 'long':
                            sl = vwap_data['lower']
                            tp = entry + (2 * (entry - sl))
                        else:
                            sl = vwap_data['upper']
                            tp = entry - (2 * (sl - entry))
                        
                        try:
                            params = {
                                'symbol': sym,
                                'positionIdx': position_idx,
                                'stopLoss': str(sl),
                                'takeProfit': str(tp)
                            }
                            self.exchange.private_post_v5_position_trading_stop(params)
                            fixed_count += 1
                            logger.info(f"✓ Added TP/SL to {sym}: SL ${sl:.6f}, TP ${tp:.6f}")
                            
                            # Update local tracking
                            if sym in self.positions:
                                self.positions[sym]['tp'] = tp
                                self.positions[sym]['sl'] = sl
                            
                            await asyncio.sleep(0.5)  # Rate limit protection
                            
                        except Exception as e:
                            logger.error(f"Failed to add TP/SL to {sym}: {e}")
                    else:
                        logger.warning(f"⚠ Could not get VWAP data for {sym}, using fallback TP/SL")
                        # Fallback: 2% SL, 4% TP
                        if direction == 'long':
                            sl = entry * 0.98
                            tp = entry * 1.04
                        else:
                            sl = entry * 1.02
                            tp = entry * 0.96
                        
                        try:
                            params = {
                                'symbol': sym,
                                'positionIdx': position_idx,
                                'stopLoss': str(sl),
                                'takeProfit': str(tp)
                            }
                            self.exchange.private_post_v5_position_trading_stop(params)
                            fixed_count += 1
                            logger.info(f"✓ Added fallback TP/SL to {sym}: SL ${sl:.6f}, TP ${tp:.6f}")
                            
                            if sym in self.positions:
                                self.positions[sym]['tp'] = tp
                                self.positions[sym]['sl'] = sl
                            
                            await asyncio.sleep(0.5)
                            
                        except Exception as e:
                            logger.error(f"Failed to add fallback TP/SL to {sym}: {e}")
            
            if fixed_count > 0:
                logger.info(f"✓ Fixed {fixed_count} positions missing TP/SL")
        
        except Exception as e:
            logger.error(f"TP/SL check error: {e}")
    
    async def close_position(self, symbol: str, pos_data: dict, reason: str):
        try:
            side = 'sell' if pos_data['direction'] == 'long' else 'buy'
            idx = 1 if pos_data['direction'] == 'long' else 2
            
            self.exchange.create_order(
                symbol, 'market', side, pos_data['amount'],
                params={'positionIdx': idx, 'reduceOnly': True}
            )
            
            ticker = self.exchange.fetch_ticker(symbol)
            current = ticker['last']
            entry = pos_data['entry_price']
            
            if pos_data['direction'] == 'long':
                pnl_pct = ((current - entry) / entry) * 100
            else:
                pnl_pct = ((entry - current) / entry) * 100
            
            pnl = pos_data['amount'] * abs(current - entry) * (1 if pnl_pct > 0 else -1)
            status = 'won' if pnl > 0 else ('lost' if pnl < 0 else 'breakeven')
            
            self.tracker.add_trade(symbol, pos_data['direction'], entry, current, pnl, pnl_pct, status, reason)
            
            logger.info(f"✗ Closed {symbol} {pos_data['direction'].upper()}: ${pnl:.2f} ({pnl_pct:.2f}%) - {reason}")
            
            if symbol in self.positions:
                del self.positions[symbol]
            if symbol in self.known_symbols:
                self.known_symbols.remove(symbol)
            
            return True
        except Exception as e:
            logger.error(f"Close failed {symbol}: {e}")
            return False
    
    async def close_all(self, reason="manual"):
        try:
            # Cancel orders
            orders = self.exchange.fetch_open_orders()
            for o in orders:
                if o['status'] == 'open' and o['symbol'] not in self.alien_symbols:
                    try:
                        self.exchange.cancel_order(o['id'], o['symbol'])
                    except:
                        pass
            
            # Close positions
            positions = self.exchange.fetch_positions()
            for p in positions:
                if float(p.get('contracts', 0)) > 0:
                    sym = p['symbol']
                    
                    if sym in self.alien_symbols:
                        continue
                    
                    if sym in self.positions:
                        await self.close_position(sym, self.positions[sym], reason)
                    else:
                        size = float(p['contracts'])
                        side = 'sell' if p['side'] == 'long' else 'buy'
                        idx = 1 if p['side'] == 'long' else 2
                        try:
                            self.exchange.create_order(sym, 'market', side, size, params={'positionIdx': idx, 'reduceOnly': True})
                        except:
                            pass
            
            self.positions.clear()
            self.known_symbols.clear()
            self.portfolio_peak = 0
            return True
        except:
            return False
    
    async def place_order(self, trade: dict, amount: float):
        sym = trade['symbol']
        direction = trade['direction']
        vwap = trade['vwap_data']
        
        longs, shorts = self.get_exposure()
        
        if direction == 'long' and longs >= self.max_longs:
            return False
        if direction == 'short' and shorts >= self.max_shorts:
            return False
        
        entry = vwap['vwap']
        
        if direction == 'long':
            side, idx = 'buy', 1
            sl = vwap['lower']
            tp = entry + (2 * (entry - sl))
        else:
            side, idx = 'sell', 2
            sl = vwap['upper']
            tp = entry - (2 * (sl - entry))
        
        try:
            try:
                self.exchange.set_leverage(self.leverage, sym, params={'buyLeverage': str(self.leverage), 'sellLeverage': str(self.leverage)})
                await asyncio.sleep(0.3)
            except:
                pass
            
            order = self.exchange.create_order(
                sym, 'limit', side, amount, entry,
                params={'positionIdx': idx, 'stopLoss': str(sl), 'takeProfit': str(tp)}
            )
            
            self.positions[sym] = {
                'direction': direction,
                'entry_price': entry,
                'amount': amount,
                'tp': tp,
                'sl': sl,
                'order_id': order['id']
            }
            self.known_symbols.add(sym)
            
            logger.info(f"✓ {direction.upper()} {sym}: Entry ${entry:.6f}, SL ${sl:.6f}, TP ${tp:.6f}")
            
            # Verify TP/SL were set correctly (wait for order to fill first)
            await asyncio.sleep(2)
            try:
                positions = self.exchange.fetch_positions([sym])
                for p in positions:
                    if float(p.get('contracts', 0)) > 0:
                        has_tp = p.get('takeProfit') and float(p.get('takeProfit', 0)) > 0
                        has_sl = p.get('stopLoss') and float(p.get('stopLoss', 0)) > 0
                        
                        if not has_tp or not has_sl:
                            logger.warning(f"⚠ TP/SL not set on {sym}, adding manually...")
                            params = {
                                'symbol': sym,
                                'positionIdx': idx,
                                'stopLoss': str(sl),
                                'takeProfit': str(tp)
                            }
                            self.exchange.private_post_v5_position_trading_stop(params)
                            logger.info(f"✓ Manually added TP/SL to {sym}")
            except Exception as e:
                logger.warning(f"Could not verify TP/SL for {sym}: {e}")
            
            return True
        except Exception as e:
            logger.error(f"Order failed {sym}: {e}")
            self.failed_symbols.add(sym)
            return False
    
    async def monitor(self):
        self.monitoring = True
        logger.info("Monitoring started")
        
        while self.monitoring:
            try:
                await self.detect_aliens()
                await self.check_add_tpsl()
                
                if not self.positions:
                    await asyncio.sleep(10)
                    continue
                
                positions = self.exchange.fetch_positions()
                portfolio_pnl = 0
                
                for p in positions:
                    if float(p.get('contracts', 0)) <= 0:
                        continue
                    
                    sym = p['symbol']
                    if sym in self.alien_symbols or sym not in self.positions:
                        continue
                    
                    pnl = float(p.get('unrealisedPnl', 0))
                    portfolio_pnl += pnl
                
                if portfolio_pnl > self.portfolio_peak:
                    self.portfolio_peak = portfolio_pnl
                
                if self.portfolio_peak > 100:
                    giveback = self.portfolio_peak - portfolio_pnl
                    giveback_pct = (giveback / self.portfolio_peak) * 100
                    
                    if giveback_pct >= 40:
                        logger.warning(f"Portfolio reversal 40%: ${portfolio_pnl:.2f} from ${self.portfolio_peak:.2f}")
                        await self.close_all("portfolio_reversal_40%")
                        self.portfolio_peak = 0
                
                await asyncio.sleep(10)
            except Exception as e:
                logger.error(f"Monitor error: {e}")
                await asyncio.sleep(10)
    
    async def run_cycle(self):
        try:
            logger.info("=" * 50)
            logger.info("Trading Cycle - 10/10 Limit + Alien Detection")
            logger.info("=" * 50)
            
            await self.detect_aliens()
            
            balance = self.get_balance()
            if balance <= 0:
                await asyncio.sleep(5)
                balance = self.get_balance()
                if balance <= 0:
                    return
            
            if not self.active:
                self.tracker.start(balance)
                self.active = True
            
            self.tracker.update_balance(balance)
            
            # Periodic report
            if (datetime.now() - self.notifier.last_report).total_seconds() >= 43200:
                positions = self.exchange.fetch_positions()
                longs = sum(1 for p in positions if float(p.get('contracts', 0)) > 0 and p['side'] == 'long' and p['symbol'] not in self.alien_symbols)
                shorts = sum(1 for p in positions if float(p.get('contracts', 0)) > 0 and p['side'] == 'short' and p['symbol'] not in self.alien_symbols)
                
                stats = {
                    'balance': balance,
                    'start_balance': self.tracker.start_balance,
                    'pnl': balance - self.tracker.start_balance,
                    'pnl_pct': ((balance - self.tracker.start_balance) / self.tracker.start_balance * 100) if self.tracker.start_balance > 0 else 0,
                    'positions': longs + shorts,
                    'longs': longs,
                    'shorts': shorts,
                    'total': len(self.tracker.trades),
                    'won': self.tracker.won,
                    'lost': self.tracker.lost,
                    'win_rate': (self.tracker.won / len(self.tracker.trades) * 100) if self.tracker.trades else 0,
                    'peak_pnl': self.portfolio_peak,
                    'max_dd': self.tracker.max_dd
                }
                
                self.notifier.send_periodic_report(stats, self.tracker.trades, self.tracker.alien_trades)
            
            # 1-hour order reset - ONLY cancel unfilled limit entry orders
            if datetime.now() - self.order_reset > timedelta(hours=1):
                logger.info("1-hour reset: Cancelling unfilled limit orders...")
                try:
                    orders = self.exchange.fetch_open_orders()
                    cancelled_count = 0
                    
                    for o in orders:
                        if o['status'] == 'open' and o['symbol'] not in self.alien_symbols:
                            # CRITICAL: Only cancel limit orders (entry orders)
                            # Do NOT cancel stop orders (TP/SL)
                            order_type = o.get('type', '').lower()
                            
                            if order_type == 'limit':
                                try:
                                    self.exchange.cancel_order(o['id'], o['symbol'])
                                    cancelled_count += 1
                                    logger.info(f"✗ Cancelled unfilled limit: {o['symbol']}")
                                    
                                    # Remove from tracking if order wasn't filled
                                    if o['symbol'] in self.positions:
                                        del self.positions[o['symbol']]
                                    if o['symbol'] in self.known_symbols:
                                        self.known_symbols.remove(o['symbol'])
                                    
                                    await asyncio.sleep(0.5)  # Rate limit protection
                                except Exception as e:
                                    logger.error(f"Failed to cancel {o['symbol']}: {e}")
                    
                    logger.info(f"Reset complete: Cancelled {cancelled_count} unfilled orders")
                    
                    # After cancelling, check ALL positions for missing TP/SL
                    logger.info("Checking all positions for missing TP/SL...")
                    await self.check_add_tpsl()
                    
                except Exception as e:
                    logger.error(f"Order reset error: {e}")
                
                self.order_reset = datetime.now()
                await asyncio.sleep(5)
            
            longs, shorts = self.get_exposure()
            
            long_slots = self.max_longs - longs
            short_slots = self.max_shorts - shorts
            
            if long_slots == 0 and short_slots == 0:
                logger.info(f"At capacity ({longs}/10 longs, {shorts}/10 shorts)")
                return
            
            symbols = self.get_symbols()
            if not symbols:
                return
            
            opps_long, opps_short = self.find_opportunities(symbols)
            
            selected_longs = opps_long[:long_slots] if long_slots > 0 else []
            selected_shorts = opps_short[:short_slots] if short_slots > 0 else []
            
            if not selected_longs and not selected_shorts:
                logger.info("No opportunities")
                return
            
            logger.info(f"Selected: {len(selected_longs)} longs (slots: {long_slots}), {len(selected_shorts)} shorts (slots: {short_slots})")
            
            bal_info = self.exchange.fetch_balance()
            total_account = float(bal_info.get('USDT', {}).get('total', 0))
            
            if total_account <= 0:
                return
            
            # Uniform position sizing: 0.1% × leverage × (leverage/2)
            uniform_margin = total_account * 0.001
            uniform_value = uniform_margin * self.leverage * (self.leverage / 2)
            
            logger.info(f"Account: ${total_account:.2f}, Position value: ${uniform_value:.2f}")
            
            placed_longs = 0
            placed_shorts = 0
            
            # Place longs
            for trade in selected_longs:
                current_longs, _ = self.get_exposure()
                if current_longs >= self.max_longs:
                    break
                
                try:
                    price = trade['vwap_data']['vwap']
                    market = self.exchange.market(trade['symbol'])
                    min_amount = float(market.get('limits', {}).get('amount', {}).get('min', 0.01))
                    
                    amount = uniform_value / price
                    precision = market.get('precision', {}).get('amount', 3)
                    amount = math.floor(amount * (10 ** precision)) / (10 ** precision)
                    
                    if amount < min_amount:
                        self.failed_symbols.add(trade['symbol'])
                        continue
                    
                    if await self.place_order(trade, amount):
                        placed_longs += 1
                    await asyncio.sleep(1)
                except Exception as e:
                    logger.error(f"Failed long {trade['symbol']}: {e}")
            
            # Place shorts
            for trade in selected_shorts:
                _, current_shorts = self.get_exposure()
                if current_shorts >= self.max_shorts:
                    break
                
                try:
                    price = trade['vwap_data']['vwap']
                    market = self.exchange.market(trade['symbol'])
                    min_amount = float(market.get('limits', {}).get('amount', {}).get('min', 0.01))
                    
                    amount = uniform_value / price
                    precision = market.get('precision', {}).get('amount', 3)
                    amount = math.floor(amount * (10 ** precision)) / (10 ** precision)
                    
                    if amount < min_amount:
                        self.failed_symbols.add(trade['symbol'])
                        continue
                    
                    if await self.place_order(trade, amount):
                        placed_shorts += 1
                    await asyncio.sleep(1)
                except Exception as e:
                    logger.error(f"Failed short {trade['symbol']}: {e}")
            
            logger.info(f"Placed {placed_longs} longs, {placed_shorts} shorts")
            
            if placed_longs + placed_shorts > 0:
                await asyncio.sleep(3)
                final_longs, final_shorts = self.get_exposure()
                logger.info(f"Final: {final_longs}/10 longs, {final_shorts}/10 shorts")
        
        except Exception as e:
            logger.error(f"Cycle error: {e}")
            import traceback
            traceback.print_exc()

async def main():
    API_KEY = "wTECac16kuNJyGJp15"
    API_SECRET = "jcVUfJmJki0j95DKp6JV6P9TM6y6N39fvI8p"
    
    print("""
    ╔═════════════════════════════════════════════╗
    ║   Bybit Bot - Optimized & Clean            ║
    ║   • 10/10 strict enforcement               ║
    ║   • 👽 Alien detection                      ║
    ║   • Auto TP/SL addition for missing        ║
    ║   • CSV reports via email (no disk save)   ║
    ║   • Efficient & streamlined                ║
    ╚═════════════════════════════════════════════╝
    """)
    
    bot = BybitBot(API_KEY, API_SECRET)
    
    try:
        balance = bot.get_balance()
        logger.info(f"Connected: ${balance:.2f}")
        logger.info(f"Email: {bot.notifier.receiver}")
        logger.info("Features: Alien detection, Auto TP/SL, Email CSV reports")
    except Exception as e:
        logger.error(f"Connection failed: {e}")
        return
    
    monitor_task = asyncio.create_task(bot.monitor())
    
    try:
        while True:
            try:
                await bot.run_cycle()
                logger.info("Waiting 60s...")
                await asyncio.sleep(60)
            
            except KeyboardInterrupt:
                logger.info("Shutting down...")
                bot.monitoring = False
                await monitor_task
                
                if bot.active:
                    final_balance = bot.get_balance()
                    duration = (datetime.now() - bot.tracker.start_time).total_seconds() / 60
                    
                    stats = {
                        'start_time': bot.tracker.start_time.isoformat(),
                        'duration': duration,
                        'balance': final_balance,
                        'start_balance': bot.tracker.start_balance,
                        'pnl': final_balance - bot.tracker.start_balance,
                        'pnl_pct': ((final_balance - bot.tracker.start_balance) / bot.tracker.start_balance * 100) if bot.tracker.start_balance > 0 else 0,
                        'total': len(bot.tracker.trades),
                        'won': bot.tracker.won,
                        'lost': bot.tracker.lost,
                        'win_rate': (bot.tracker.won / len(bot.tracker.trades) * 100) if bot.tracker.trades else 0,
                        'max_dd': bot.tracker.max_dd
                    }
                    
                    bot.notifier.send_session_end(stats, bot.tracker.trades, bot.tracker.alien_trades)
                    
                    if bot.alien_symbols:
                        logger.warning(f"👽 {len(bot.alien_symbols)} alien trades: {', '.join(list(bot.alien_symbols)[:5])}")
                
                break
            
            except Exception as e:
                logger.error(f"Main loop error: {e}")
                await asyncio.sleep(60)
    
    finally:
        bot.monitoring = False
        try:
            await monitor_task
        except:
            pass
        logger.info("Bot stopped")

if __name__ == "__main__":
    asyncio.run(main())
